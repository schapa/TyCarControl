//****************************************************************************
// Model: debugTracer.qm
// File:  ./DebugTracer.cpp
//
// This code has been generated by QM tool (see state-machine.com/qm).
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// This program is open source software: you can redistribute it and/or
// modify it under the terms of the GNU General Public License as published
// by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
// for more details.
//****************************************************************************
//${Tracer::.::DebugTracer.cpp} ..............................................

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include "DebugTracer.h"
#include "BoardSupportPackage.h"
#include "UartController.h"
#include "myEvents.h"

namespace DT {

//${Tracer::DebugTracer} .....................................................
//${Tracer::DebugTracer::DebugTracer} ........................................
DebugTracer::DebugTracer()
  : QMActive(Q_STATE_CAST(&DebugTracer::initial)),
    tracer(*this),
    traceStringSize(512) {
    tracer.init();
}

//${Tracer::DebugTracer::~DebugTracer} .......................................
DebugTracer::~DebugTracer() {
    //
}
//${Tracer::DebugTracer::getInstance} ........................................
DebugTracer& DebugTracer::getInstance() {
    static DebugTracer instance;
    return instance;
}
//${Tracer::DebugTracer::trace} ..............................................
void DebugTracer::trace(const char *__restrict fmt, ... ) {
    QP::DataEvt *evt = Q_NEW(QP::DataEvt, TRACE_SIG);
    int writeSize = 0;
    evt->string = new char[traceStringSize];
    if (!evt->string) {
        static const char *const memoryError = "Cannot allocate data. Dropping trace.";
        evt->string = const_cast<char*>(memoryError);
        writeSize = strlen(memoryError);
    } else {
        va_list args;
        va_start (args, fmt);
        writeSize = vsnprintf (evt->string, traceStringSize-3, fmt, args);
        va_end (args);
    }
    evt->string[writeSize++] = '\n';
    evt->string[writeSize++] = '\r';
    evt->string[writeSize++] = '\0';
    post_( evt, 0);
}
//${Tracer::DebugTracer::SM} .................................................
QP::QState DebugTracer::initial(DebugTracer * const me, QP::QEvt const * const e) {
    static QP::QMTranActTable const tatbl_ = { // transition-action table
        &ActiveState_s,
        {
            Q_ACTION_CAST(0)  // zero terminator
        }
    };
    // ${Tracer::DebugTracer::SM::initial}
    return QM_TRAN_INIT(&tatbl_);
}
//${Tracer::DebugTracer::SM::ActiveState} ....................................
QP::QMState const DebugTracer::ActiveState_s = {
    static_cast<QP::QMState const *>(0), // superstate (top)
    Q_STATE_CAST(&ActiveState),
    Q_ACTION_CAST(0), // no entry action
    Q_ACTION_CAST(0), // no exit action
    Q_ACTION_CAST(0)  // no intitial tran.
};
// ${Tracer::DebugTracer::SM::ActiveState}
QP::QState DebugTracer::ActiveState(DebugTracer * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${Tracer::DebugTracer::SM::ActiveState::TRACE}
        case TRACE_SIG: {
            QP::DataEvt *evt = static_cast<QP::DataEvt *>(const_cast<QP::QEvt*>(e));
            evt->sig = UC::SEND_NEW_SIG;
                BSP::system.setLedState(BSP::RED_LED, true);
            me->tracer.dispatch(e);
            status_ = QM_HANDLED();
            break;
        }
        // ${Tracer::DebugTracer::SM::ActiveState::CHAR}
        case CHAR_SIG: {
            QP::DataEvt *evt = static_cast<QP::DataEvt *>(const_cast<QP::QEvt*>(e));
            evt->sig = UC::RECV_NEW_SIG;
            me->tracer.dispatch(e);
            status_ = QM_HANDLED();
            break;
        }
        // ${Tracer::DebugTracer::SM::ActiveState::NEW_BUFFERED_STR~}
        case NEW_BUFFERED_STRING_SIG: {
            const QP::DataEvt *const recieved = static_cast<const QP::DataEvt*const>(e);
            /* work with it */
            me->trace("[%s]", recieved->string);
            free(recieved->ptr);
            status_ = QM_HANDLED();
            break;
        }
        // ${Tracer::DebugTracer::SM::ActiveState::TRANSMITION_COMP~}
        case TRANSMITION_COMPLETE_SIG: {
            QP::DataEvt *evt = static_cast<QP::DataEvt *>(const_cast<QP::QEvt*>(e));
            evt->sig = UC::SEND_SUCESSFULL_SIG;
                BSP::system.setLedState(BSP::RED_LED, false);
            me->tracer.dispatch(e);
            status_ = QM_HANDLED();
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    return status_;
}


void TraceChannelController::onReception(const char& character) {
}

bool TraceChannelController::sendData(const char * buff) {
    return BSP::system.debugTraceAsync(buff) != 0;
}

DebugTracer& item = DebugTracer::getInstance();

}
