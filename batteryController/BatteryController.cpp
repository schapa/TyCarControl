//****************************************************************************
// Model: model.qm
// File:  ./BatteryController.cpp
//
// This code has been generated by QM tool (see state-machine.com/qm).
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// This program is open source software: you can redistribute it and/or
// modify it under the terms of the GNU General Public License as published
// by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
// for more details.
//****************************************************************************
//${ActiveObjects::.::BatteryControlle~} .....................................
#include "qp_port.h"
#include "BatteryController.h"
#include <stdint.h>
#include "BoardSupportPackage.h"
#include "DebugTracer.h"
namespace BC {

//${ActiveObjects::BatteryControlle~} ........................................
//${ActiveObjects::BatteryControlle~::BatteryControlle~} .....................
BatteryController::BatteryController()
  : QMActive(Q_STATE_CAST(&BatteryController::initial)),
    chargedValue(4250),
    dischargedValue(3520) {
}

//${ActiveObjects::BatteryControlle~::~BatteryControll~} .....................
BatteryController::~BatteryController() {
    /* no! */
}
//${ActiveObjects::BatteryControlle~::getValue} ..............................
uint32_t& BatteryController::getValue() {
    return currentValue;
}
//${ActiveObjects::BatteryControlle~::getPercentage} .........................
uint32_t BatteryController::getPercentage() {
    const uint32_t fullRange = chargedValue - dischargedValue;
    uint32_t percentage = 100*currentValue/fullRange;
    //printf("Current value is [%d %]\n", percentage);
    return percentage;
}
//${ActiveObjects::BatteryControlle~::getInstance} ...........................
BatteryController& BatteryController::getInstance() {
    static BatteryController instance;
    return instance;
}
//${ActiveObjects::BatteryControlle~::SM} ....................................
QP::QState BatteryController::initial(BatteryController * const me, QP::QEvt const * const e) {
    static struct {
        QP::QMState const *target;
        QP::QActionHandler act[3];
    } const tatbl_ = { // transition-action table
        &IdleState_s,
        {
            Q_ACTION_CAST(&commonState_e), // entry
            Q_ACTION_CAST(&IdleState_e), // entry
            Q_ACTION_CAST(0)  // zero terminator
        }
    };
    // ${ActiveObjects::BatteryControlle~::SM::initial}
    /* supress warnging */
    DT::item.trace("Initial transition of battery controller");
    (void)e;
    return QM_TRAN_INIT(&tatbl_);
}
//${ActiveObjects::BatteryControlle~::SM::commonState} .......................
QP::QMState const BatteryController::commonState_s = {
    static_cast<QP::QMState const *>(0), // superstate (top)
    Q_STATE_CAST(&commonState),
    Q_ACTION_CAST(&commonState_e),
    Q_ACTION_CAST(&commonState_x),
    Q_ACTION_CAST(0)  // no intitial tran.
};
// ${ActiveObjects::BatteryControlle~::SM::commonState}
QP::QState BatteryController::commonState_e(BatteryController * const me) {
    /* BSP_ADC_StartVoltageMonitor() */
    DT::item.trace("commonState Entry!");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_ENTRY(&commonState_s);
}
// ${ActiveObjects::BatteryControlle~::SM::commonState}
QP::QState BatteryController::commonState_x(BatteryController * const me) {
    /* BSP_ADC_StopVoltageMonitor() */
    DT::item.trace("commonState Exit!");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_EXIT(&commonState_s);
}
// ${ActiveObjects::BatteryControlle~::SM::commonState}
QP::QState BatteryController::commonState(BatteryController * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${ActiveObjects::BatteryControlle~::SM::commonState::NEW_BATTERY_VALU~}
        case NEW_BATTERY_VALUE_SIG: {
            DT::item.trace("NEW_BATTERY_VALUE");
            status_ = QM_HANDLED();
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    (void)me; /* avoid compiler warning in case 'me' is not used */
    return status_;
}
//${ActiveObjects::BatteryControlle~::SM::commonState::IdleState} ............
QP::QMState const BatteryController::IdleState_s = {
    &BatteryController::commonState_s, // superstate
    Q_STATE_CAST(&IdleState),
    Q_ACTION_CAST(&IdleState_e),
    Q_ACTION_CAST(&IdleState_x),
    Q_ACTION_CAST(0)  // no intitial tran.
};
// ${ActiveObjects::BatteryControlle~::SM::commonState::IdleState}
QP::QState BatteryController::IdleState_e(BatteryController * const me) {
    DT::item.trace("IdleState Entry!");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_ENTRY(&IdleState_s);
}
// ${ActiveObjects::BatteryControlle~::SM::commonState::IdleState}
QP::QState BatteryController::IdleState_x(BatteryController * const me) {
    DT::item.trace("IdleState Exit!");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_EXIT(&IdleState_s);
}
// ${ActiveObjects::BatteryControlle~::SM::commonState::IdleState}
QP::QState BatteryController::IdleState(BatteryController * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${ActiveObjects::BatteryControlle~::SM::commonState::IdleState::LOW_BATTERY}
        case LOW_BATTERY_SIG: {
            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[3];
            } const tatbl_ = { // transition-action table
                &lowBatteryState_s,
                {
                    Q_ACTION_CAST(&IdleState_x), // exit
                    Q_ACTION_CAST(&lowBatteryState_e), // entry
                    Q_ACTION_CAST(0)  // zero terminator
                }
            };
            DT::item.trace("LOW_BATTERY_SIG");
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    return status_;
}
//${ActiveObjects::BatteryControlle~::SM::commonState::lowBatteryState} ......
QP::QMState const BatteryController::lowBatteryState_s = {
    &BatteryController::commonState_s, // superstate
    Q_STATE_CAST(&lowBatteryState),
    Q_ACTION_CAST(&lowBatteryState_e),
    Q_ACTION_CAST(&lowBatteryState_x),
    Q_ACTION_CAST(0)  // no intitial tran.
};
// ${ActiveObjects::BatteryControlle~::SM::commonState::lowBatteryState}
QP::QState BatteryController::lowBatteryState_e(BatteryController * const me) {
    DT::item.trace("lowBatteryState Entry!");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_ENTRY(&lowBatteryState_s);
}
// ${ActiveObjects::BatteryControlle~::SM::commonState::lowBatteryState}
QP::QState BatteryController::lowBatteryState_x(BatteryController * const me) {
    DT::item.trace("lowBatteryState Exit!");
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_EXIT(&lowBatteryState_s);
}
// ${ActiveObjects::BatteryControlle~::SM::commonState::lowBatteryState}
QP::QState BatteryController::lowBatteryState(BatteryController * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${ActiveObjects::BatteryControlle~::SM::commonState::lowBatteryState::FULL_BATTERY}
        case FULL_BATTERY_SIG: {
            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[3];
            } const tatbl_ = { // transition-action table
                &IdleState_s,
                {
                    Q_ACTION_CAST(&lowBatteryState_x), // exit
                    Q_ACTION_CAST(&IdleState_e), // entry
                    Q_ACTION_CAST(0)  // zero terminator
                }
            };
            DT::item.trace("FULL_BATTERY");
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    return status_;
}


BatteryController& item = BatteryController::getInstance();

}

